package mapper

import (
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/go-sphere/entc-extensions/autoproto/utils/gofile"
	"github.com/go-sphere/entc-extensions/autoproto/utils/inspect"
	"github.com/iancoleman/strcase"
)

// GenFilesConf defines the configuration for generating multiple files with mapping functions.
type GenFilesConf struct {
	Dir      string
	Package  string
	Entities []GenFileEntityConf
}

// GenFileEntityConf defines configuration for generating a mapping file between a source and target entity.
type GenFileEntityConf struct {
	Source        any
	Target        any
	SourcePkgName string
	TargetPkgName string
	IgnoreFields  []string
}

// GenerateFiles generates mapping files for specified entities using the provided configuration.
// It removes existing files in the target directory and creates new ones based on the configuration.
// Returns an error if the directory is invalid, cleanup fails, or file generation encounters issues.
func GenerateFiles(options *GenFilesConf) error {
	if options.Dir == "" {
		return fmt.Errorf("directory is required")
	}
	if err := os.RemoveAll(options.Dir); err != nil {
		return fmt.Errorf("cleanup mapper dir: %w", err)
	}
	if err := os.MkdirAll(options.Dir, 0o755); err != nil {
		return fmt.Errorf("create mapper dir: %w", err)
	}

	packageName := options.Package
	if packageName == "" {
		packageName = "mapper"
	}
	for _, entity := range options.Entities {
		if entity.Source == nil || entity.Target == nil {
			return fmt.Errorf("mapper entity must provide both source and target types")
		}
		funcConf := NewGenFuncConf(entity.Source, entity.Target)
		if entity.SourcePkgName != "" {
			funcConf.WithSourcePkgName(entity.SourcePkgName)
		}
		if entity.TargetPkgName != "" {
			funcConf.WithTargetPkgName(entity.TargetPkgName)
		}
		if len(entity.IgnoreFields) > 0 {
			funcConf.WithIgnoreFields(entity.IgnoreFields...)
		}

		fileName := filepath.Join(options.Dir, strcase.ToSnake(inspect.TypeName(entity.Source))+".go")
		err := genFile(fileName, packageName, []*GenFuncConf{
			funcConf,
		})
		if err != nil {
			return err
		}
	}
	return nil
}

func genFile(fileName string, pkgName string, funcs []*GenFuncConf) error {
	var body strings.Builder
	imports := [][2]string{{"fmt", ""}}
	for _, fn := range funcs {
		if fn == nil {
			continue
		}
		imports = append(imports,
			inspect.ExtractPackageImport(fn.source),
			inspect.ExtractPackageImport(fn.target),
		)
		content, err := GenFunc(fn)
		if err != nil {
			return err
		}
		body.WriteString(content)
		body.WriteString("\n")
	}

	var file strings.Builder
	file.WriteString("// Code generated by Sphere. DO NOT EDIT.\n")
	file.WriteString("package ")
	file.WriteString(pkgName)
	file.WriteString("\n\n")
	file.WriteString("import (\n")
	for _, imp := range inspect.DeduplicateImports(imports) {
		file.WriteString("\t")
		if imp[1] != "" {
			file.WriteString(imp[1] + " ")
		}
		file.WriteString(strconv.Quote(imp[0]))
		file.WriteString("\n")
	}
	file.WriteString(")\n\n")
	file.WriteString(body.String())

	return gofile.WriteFile(fileName, []byte(file.String()))
}
