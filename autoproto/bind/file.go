package bind

import (
	_ "embed"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/go-sphere/entc-extensions/autoproto/utils/gofile"
	"github.com/go-sphere/entc-extensions/autoproto/utils/inspect"
	"github.com/go-sphere/entc-extensions/autoproto/utils/strcase"
)

// GenFilesConf holds configuration for generating a complete Go file with multiple binding functions.
// It coordinates the generation of binding code for multiple entities and their operations.
type GenFilesConf struct {
	Dir          string
	Package      string
	Entities     []GenFileEntityConf
	ExtraImports [][2]string
}

// GenFileEntityConf represents configuration for a single entity's binding generation.
// It defines the actions to generate and how to build configuration for each action.
type GenFileEntityConf struct {
	Source  any
	Target  any
	Actions []any
	Options []GenBindConfOption
}

// GenFiles generates a complete Go source file containing binding functions for multiple entities.
// It creates properly formatted Go code with imports and multiple binding functions
// based on the provided configuration. Returns formatted Go source code or an error.
func GenFiles(config *GenFilesConf) error {
	if config.Dir == "" {
		return fmt.Errorf("directory is required")
	}
	if err := os.RemoveAll(config.Dir); err != nil {
		return fmt.Errorf("cleanup mapper dir: %w", err)
	}
	if err := os.MkdirAll(config.Dir, 0o755); err != nil {
		return fmt.Errorf("create mapper dir: %w", err)
	}
	pkgName := config.Package
	if pkgName == "" {
		pkgName = "bind"
	}
	for _, item := range config.Entities {
		filename := filepath.Join(config.Dir, fmt.Sprintf("%s.go", strcase.ToSnake(inspect.TypeName(item.Source))))
		err := genFile(filename, pkgName, &item, config.ExtraImports)
		if err != nil {
			return err
		}
	}
	return nil
}

func genFile(fileName string, pkgName string, item *GenFileEntityConf, extraImports [][2]string) error {
	var file strings.Builder
	var body strings.Builder

	pkgImports := [][2]string{
		inspect.ExtractPackageImport(Options{}),
	}
	pkgImports = append(pkgImports, extraImports...)

	for i, act := range item.Actions {
		conf := NewGenBindConf(item.Source, item.Target, act)
		for _, opt := range item.Options {
			opt(conf)
		}
		pkgImports = append(pkgImports,
			inspect.ExtractPackageImport(act),
			inspect.ExtractPackageImport(conf.source),
			inspect.ExtractPackageImport(conf.target),
		)
		if i == 0 {
			entityName := strings.ToLower(inspect.ExtractTypeName(conf.source))
			pkgImports = append(pkgImports, [2]string{
				path.Join(inspect.ExtractPackagePath(conf.source), entityName),
				entityName,
			})
		}
		funcContent, err := GenBindFunc(conf)
		if err != nil {
			return err
		}
		body.WriteString(funcContent)
		body.WriteString("\n")
	}

	file.WriteString("// Code generated by Sphere. DO NOT EDIT.\n")
	file.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	file.WriteString("import (\n")
	for _, imp := range inspect.DeduplicateImports(pkgImports) {
		file.WriteString("\t")
		if imp[1] != "" {
			file.WriteString(imp[1] + " ")
		}
		file.WriteString(strconv.Quote(imp[0]) + "\n")
	}
	file.WriteString(")\n\n")
	file.WriteString(body.String())

	err := gofile.WriteFile(fileName, []byte(file.String()))
	if err != nil {
		return err
	}
	return nil
}
