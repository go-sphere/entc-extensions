package gofile

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/go-sphere/entc-extensions/entgen/inspect"
	"golang.org/x/tools/imports"
)

// WriteFile formats and writes content to the specified file, overwriting it if it exists. Returns an error if failures occur.
func WriteFile(fileName string, content []byte) error {
	content, err := imports.Process(fileName, content, nil)
	if err != nil {
		return err
	}
	content, err = format.Source(content)
	if err != nil {
		return err
	}
	err = os.WriteFile(fileName, content, 0o644)
	if err != nil {
		return err
	}
	return nil
}

// CreateGoFile generates a Go source file with the specified package, imports, and body content.
// pkgName specifies the name of the package for the generated file.
// pkgImports is a list of [path, alias] pairs for import statements. Alias can be empty for default imports.
// body contains the Go code to be included as the main content of the file.
// Returns the formatted Go source as a string.
func CreateGoFile(pkgName string, pkgImports [][2]string, body string) string {
	var file strings.Builder
	file.WriteString("// Code generated by Sphere. DO NOT EDIT.\n")
	file.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	file.WriteString("import (\n")
	for _, imp := range inspect.DeduplicateImports(pkgImports) {
		file.WriteString("\t")
		if imp[1] != "" {
			file.WriteString(imp[1] + " ")
		}
		file.WriteString(strconv.Quote(imp[0]))
		file.WriteString("\n")
	}
	file.WriteString(")\n\n")
	file.WriteString(body)
	return file.String()
}

// CreateDir creates a directory with the specified path. Optionally removes the directory if it exists before creation.
// Returns an error if the directory cannot be created or removed.
func CreateDir(dir string, removeBeforeGenerate bool) error {
	if dir == "" {
		return fmt.Errorf("directory is required")
	}
	if removeBeforeGenerate {
		if err := os.RemoveAll(dir); err != nil {
			return fmt.Errorf("cleanup dir: %w", err)
		}
	}
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("create dir: %w", err)
	}
	return nil
}

type Filenames struct {
	dir   string
	names map[string]int
}

// NewFilenames initializes and returns a Filenames instance for managing unique filenames in the specified directory.
func NewFilenames(dir string) *Filenames {
	return &Filenames{dir: dir, names: map[string]int{}}
}

// Next generates a unique filename based on the given name by appending an index if the name has been used previously.
func (f *Filenames) Next(name string) string {
	count := f.names[name]
	if count == 0 {
		return filepath.Join(f.dir, name+".go")
	} else {
		count++
		f.names[name] = count
		return filepath.Join(f.dir, name+"_"+strconv.Itoa(count)+".go")
	}
}
